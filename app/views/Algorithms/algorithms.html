<pre  class="brush: js;">
function BubbleSort(array) {
　 var length = array.length;
   var sub_length = length;
　　for(i=0; i<=length-2; i++, sub_length--) {
　　　　for(j=1; j<= sub_length - 1; j++) {
　　　　　　//对两个元素进行交换
　　　　　　if(array[j] < array[j-1]) {
　　　　　　　　temp = array[j];
　　　　　　　　array[j] = array[j-1];
　　　　　　　　array[j-1] = temp;
　　　　　　}
　　　　}
　　}
  return array;
}
</pre>

<pre class="brush: js;">
	function quickSort(arr){
		// 如果数组只有一项，就返回原数组
		if(arr.length <= 1){
			return arr;
		} else {
			    // 取数组中间项数
			var pivotIndex = Math.floor(arr.length / 2),
			    // 取到剔除数组的中间改项数
			    pivot = arr.splice(pivotIndex, 1),
			    leftArray = [],
			    rightArray = [];
			for(var i = 0, len = arr.length; i < len; i++){
				// 如果该循环项小于“基准”项，放进左边数组，否则放进右边数组
				if(arr[i] < pivot){
					leftArray.push(arr[i]);
				} else {
					rightArray.push(arr[i]);
				}
			}
			// 不断递归调用，然后把结果拼接成最后的结果数组
			// return arguments.callee(leftArray).concat(pivot, arguments.callee(rightArray));
			return quickSort(leftArray).concat(pivot, quickSort(rightArray));
		}
	}

</pre>

<pre class="brush: js;">
	function selectionSort(arr) {
	      var i, j, minIndex, tmp;
	      var n = arr.length;
	      for (i = 0; i < n - 1; i++) {
	            minIndex = i;
	            for (j = i + 1; j < n; j++)
	                  if (arr[j] < arr[minIndex])
	                        minIndex = j;
	            if (minIndex != i) {
	                  tmp = arr[i];
	                  arr[i] = arr[minIndex];
	                  arr[minIndex] = tmp;
	            }
	      }
	      return arr;
	}
	
	// OR

	function swap(items, firstIndex, secondIndex){
	    var temp = items[firstIndex];
	    items[firstIndex] = items[secondIndex];
	    items[secondIndex] = temp;
	}
	function selectionSort(items){

	    var len = items.length,
	        min;

	    for (i=0; i < len; i++){

	        //set minimum to this position
	        min = i;

	        //check the rest of the array to see if anything is smaller
	        for (j=i+1; j < len; j++){
	            if (items[j] < items[min]){
	                min = j;
	            }
	        }

	        //if the minimum isn't in the position, swap it
	        if (i != min){
	            swap(items, i, min);
	        }
	    }

	    return items;
	}
</pre>

<pre class="brush: js;">
function insertionSort(arr) {
      var i, j, newValue;
      for (i = 1; i < arr.length; i++) {
            newValue = arr[i];
            j = i;
            while (j > 0 && arr[j - 1] > newValue) {
                  arr[j] = arr[j - 1];
                  j--;
            }
            arr[j] = newValue;
      }
      return arr;
}
</pre>

<pre class="brush: js;">
function findIndex(values, target) {
  return binarySearch(values, target, 0, values.length - 1);
};

function binarySearch(values, target, start, end) {
  if (start > end) { return -1; } //does not exist

  var middle = Math.floor((start + end) / 2);
  var value = values[middle];

  if (value > target) { return binarySearch(values, target, start, middle-1); }
  if (value < target) { return binarySearch(values, target, middle+1, end); }
  return middle; //found!
}
findIndex([1, 4, 6, 7, 12, 13, 15, 18, 19, 20, 22, 24], 20);

// OR

//Copyright 2009 Nicholas C. Zakas. All rights reserved.
//MIT-Licensed, see source file
function binarySearch(items, value){

    var startIndex  = 0,
        stopIndex   = items.length - 1,
        middle      = Math.floor((stopIndex + startIndex)/2);

    while(items[middle] != value && startIndex < stopIndex){

        //adjust search area
        if (value < items[middle]){
            stopIndex = middle - 1;
        } else if (value > items[middle]){
            startIndex = middle + 1;
        }

        //recalculate middle
        middle = Math.floor((stopIndex + startIndex)/2);
    }

    //make sure it's the right value
    return (items[middle] != value) ? -1 : middle;
}
</pre>

<pre class="brush: js;">
	function BinaryTree(value, left, right) {
	    this.value = value;
	    this.left = left;
	    this.right = right;
	}
	BinaryTree.prototype.preorder  = function(f) {this.walk(f,['this','left','right'])}
	BinaryTree.prototype.inorder   = function(f) {this.walk(f,['left','this','right'])}
	BinaryTree.prototype.postorder = function(f) {this.walk(f,['left','right','this'])}
	BinaryTree.prototype.walk = function(func, order) {
	    for (var i in order) 
	        switch (order[i]) {
	            case "this": func(this.value); break;
	            case "left": if (this.left) this.left.walk(func, order); break;
	            case "right": if (this.right) this.right.walk(func, order); break;
	        }
	}
	BinaryTree.prototype.levelorder = function(func) {
	    var queue = [this];
	    while (queue.length != 0) {
	        var node = queue.shift();
	        func(node.value);
	        if (node.left) queue.push(node.left);
	        if (node.right) queue.push(node.right);
	    }
	}
	 
	// convenience function for creating a binary tree
	function createBinaryTreeFromArray(ary) {
	    var left = null, right = null;
	    if (ary[1]) left = createBinaryTreeFromArray(ary[1]);
	    if (ary[2]) right = createBinaryTreeFromArray(ary[2]);
	    return new BinaryTree(ary[0], left, right);
	}
	 
	var tree = createBinaryTreeFromArray([1, [2, [4, [7]], [5]], [3, [6, [8],[9]]]]);

	function cl(t){
		console.log(t);
	}
	tree.preorder(cl); 
	tree.inorder(cl); 
	tree.postorder(cl);
	tree.levelorder(cl);
</pre>

<script type="text/javascript-lazy" src="/scripts/syntaxhighter.js"></script>