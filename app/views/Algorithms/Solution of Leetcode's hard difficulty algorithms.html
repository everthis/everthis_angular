<div class="film-title-area">
	<h1>Solution of Leetcode's hard difficulty algorithms</h1>
</div>
<h2>#10 Regular Expression Matching</h2>
<pre class="brush: js;">
	/**
	 * @param {string} s
	 * @param {string} p
	 * @returns {boolean}
	 */
	var isMatch = function(s, p) {
	            if (p.length === 0) {
	            return s.length === 0;
	        }

	        // length == 1 is the case that is easy to forget.
	        // as p is subtracted 2 each time, so if original
	        // p is odd, then finally it will face the length 1
	        if (p.length === 1) {
	            return (s.length === 1)
	                    && (p.charAt(0) == s.charAt(0) || p.charAt(0) == '.');
	        }

	        // next char is not '*': must match current character
	        if (p.charAt(1) != '*') {
	            if (s.length < 1) {
	                return false;
	            } else {
	                return (s.charAt(0) == p.charAt(0) || p.charAt(0) == '.')
	                        && isMatch(s.substring(1), p.substring(1));
	            }
	        }
	        // next char is *
	        while (s.length > 0
	               && (p.charAt(0) == s.charAt(0) || p.charAt(0) == '.')) {
	            if (isMatch(s, p.substring(2))) {
	                return true;
	            }
	            s = s.substring(1);
	        }
	        return isMatch(s, p.substring(2));
	};
</pre>

<h2>#65 Valid Number</h2>
<pre class="brush: js;">
	/**
	 * @param {string} str
	 * @returns {boolean}
	 */
	var isNumber = function(str) {
            var i = 0;
	        // skip whitespace in the front
	        for( ; i < str.length && ' ' == str[i]; ++ i);
	        // handle positive and negative symbols
	        if('+' == str[i] || '-' == str[i])
	            ++ i;
	        // handle the following numbers
	        var digit = false, dot = false, exp = false;
	        for( ; i < str.length; ++ i) {
	            // '.' can not appear twice，there could be no numbers in front of '.'
	            if('.' == str[i] && !dot) {
	                dot = true;
	             // 'e'can not appear twice，there must numbers in front of 'e'
	            } else if('e' == str[i] && !exp && digit) {
	                // '.' must not appear behind 'e'，int (positive or negative) must be behind 'e'.
	                dot = exp = true;
	                if(i + 1 < str.length && ('+' == str[i + 1] || '-' == str[i + 1]))
	                    ++ i;
	                if(i + 1 >= str.length || !(str[i + 1] >= '0' && str[i + 1] <= '9'))
	                    return false;
	            } else if(str[i] >= '0' && str[i] <= '9') {
	                digit = true;
	            } else {
	                break;
	            }
	        }
	        // skip following space
	        for( ; i < str.length && ' ' == str[i]; ++ i);

	        return digit && i == str.length;
	};
</pre>

<h2>#68 Text Justification <span class="sub_title">2015-03-30</span></h2>
<pre class="brush: js;">
	/**
	 * @param {string[]} words
	 * @param {number} L
	 * @returns {string[]}
	 */
	var fullJustify = function(words, L) {
	    var res = [""];
	    if (words.length === 0 || L === 0) {
	        return res;
	    } else {
	        res.shift();
	        for (var i = 0, k, l; i < words.length; i += k) {
	            for (k = l = 0; i + k < words.length && l + words[i + k].length <= L - k; k++) {
	                l += words[i + k].length;
	            }
	            var tmp = words[i];
	            for (j = 0; j < k - 1; j++) {
	                if (i + k >= words.length) {
	                    tmp += " ";
	                } else {
	                	// Array(3).join('a') returns "aa"
	                    tmp += Array(parseInt((L - l) / (k - 1) + (j < (L - l) % (k - 1))) + 1 ).join(" ");
	                }
	                tmp += words[i + j + 1];
	            }
	            tmp += Array(parseInt(L - tmp.length) + 1).join(" ");
	            res.push(tmp);
	        }
	        return res;
	    }
	};
</pre>

<p>50个阶梯，一次可以上一阶或两阶，走上去，共有多少种走法?</p>
<pre class="brush: js;">
	function f(a){
	    var $={};
	    function _(a) {
	        return $[a] ? $[a] : ($[a] = a &lt;= 1 ? 1 : _(a-1) + _(a-2));
	    }
	    return _(a);
	};
	alert(f(50));
</pre>
<p class="hint">考虑到这里会有大量重复的运算，所以放置一个变量存储每个n对应的走法数。</p>

<script type="text/javascript-lazy" src="/scripts/syntaxhighter.js"></script>