<h2>Event order</h2>
<pre class="brush: css;">
	               | |
	---------------| |-----------------
	| element1     | |                |
	|   -----------| |-----------     |
	|   |element2  \ /          |     |
	|   -------------------------     |
	|        Event CAPTURING          |
	-----------------------------------
</pre>

<pre class="brush: css;">
	               / \
	---------------| |-----------------
	| element1     | |                |
	|   -----------| |-----------     |
	|   |element2  | |          |     |
	|   -------------------------     |
	|        Event BUBBLING           |
	-----------------------------------
</pre>
<p>Function declarations and variable declarations are always moved (hoisted) invisibly to the top of their containing scope by the JavaScript interpreter.</p>

<p>But in the case with function declarations, where the entire function body will be hoisted as well.</p>

<h2>JavaScript Module Pattern</h2>

<h4>Anonymous Closures</h4>
<pre class="brush: js;">
  (function () {
    // ... all vars and functions are in this scope only
    // still maintains access to all globals
  }());
</pre>

<h4>Module Export</h4>
<pre class="brush: js;">
  var MODULE = (function () {
    var my = {},
      privateVariable = 1;
    function privateMethod() {
      // ...
    }
    my.moduleProperty = 1;
    my.moduleMethod = function () {
      // ...
    };
    return my;
  }());
</pre>

<h2>basic module pattern</h2>
<pre class="brush: js;">
	var Module = (function () {

	  return {
	    publicMethod: function () {
	      // code
	    }
	  };

	})();
</pre>
<h2>Locally scoped Object Literal</h2>
<pre class="brush: js;">
	var Module = (function () {

	  // locally scoped Object
	  var myObject = {};

	  // declared with `var`, must be "private"
	  var privateMethod = function () {};

	  myObject.someMethod = function () {
	    // take it away Mr. Public Method
	  };

	  return myObject;

	})();
</pre>
OR
<pre class="brush: js;">
	var Module = (function () {

	  var privateMethod = function () {};

	  var myObject = {
	    someMethod:  function () {

	    },
	    anotherMethod:  function () {

	    }
	  };

	  return myObject;

	})();
</pre>
<h2>Accessing "Private" Methods</h2>
<pre class="brush: js;">
	var Module = (function () {

	  var privateMethod = function (message) {
	    console.log(message);
	  };

	  var publicMethod = function (text) {
	    privateMethod(text);
	  };

	  return {
	    publicMethod: publicMethod
	  };

	})();

	// Example of passing data into a private method
	// the private method will then `console.log()` 'Hello!'
	Module.publicMethod('Hello!');
</pre>
<h2>Augmentation</h2>
<pre class="brush: js;">
	var MODULE = (function (my) {
		my.anotherMethod = function () {
			// added method...
		};

		return my;
	}(MODULE || {}));
</pre>
<h2>pass Module into ModuleTwo</h2>
<pre class="brush: js;">
	var ModuleTwo = (function (Module) {

	    Module.extension = function () {
	        // another method!
	    };

	    return Module;

	})(Module || {});
</pre>
<h2>Global Import</h2>
<pre class="brush: js;">
	(function ($, YAHOO) {
		// now have access to globals jQuery (as $) and YAHOO in this code
	}(jQuery, YAHOO));
</pre>
<h2>Private Naming Conventions, using "_"</h2>
<pre class="brush: js;">
	var Module = (function () {

	  var _privateMethod = function () {
	    // private stuff
	  };

	  var publicMethod = function () {
	    _privateMethod();
	  };

	  return {
	    publicMethod: publicMethod
	  };

	})();
</pre>

<h2>.call and .apply</h2>
<p>A useful mnemonic is "A for array and C for comma."</p>
<h2>this</h2>
<p>In JavaScript this always refers to the “owner” of the function we're executing, or rather, to the object that a function is a method of.</p>
<h2>NaN is number :) Also it is the only value which does not equal itself.</h2>
<h2>ele.className and ele.getAttribute(“class”)</h2>
<p>ele.className returns a string, while ele.getAttribute(“class”) returns an object.</p>

<p>sessionStorage (as the name persists) is only available for the duration of the browser session (and is deleted when the tab is closed) - it does however survive page reloads </p>
<h2>arguments.callee</h2>
<p>It specifies the currently executing function, so arguments.callee is the current function.</p>
<h2>function.caller</h2>
<p>The function.caller property returns the function that invoked the specified function.</p>
<p>
	The new operator takes a function F and arguments: new F(arguments...). It does three easy steps:
	Create the instance of the class. It is an empty object with its __proto__ property set to F.prototype.
	Initialize the instance. The function F is called with the arguments passed and this set to be the instance.
	Return the instance
</p>
<p>
	Note that if the value of an instanceof test can change based on changes to the prototype property of constructors, it cannot be changed by changing an object prototype, because changing an object prototype is not possible in standard ECMAScript. It is however possible using the non-standard __proto__ pseudo-property.
</p>
<p>
	通过var创建的全局变量（在任何函数体之外创建的变量）不能被删除。
	没有用var创建的隐式全局变量（不考虑函数内的情况）可以被删除。
</p>
<p>
	bind returns a function which will act like the original function but with this predefined. It is usually used when you want to pass a function to an event handler or other async callback.

	call and apply will call a function immediately letting you specify both the value of this and any arguments the function will receive.
</p>
<!-- <h2>JavaScript Errors</h2>
<pre class="brush: js;">
Uncaught TypeError: undefined is not a function
</pre>
<pre class="brush: js;">
Uncaught ReferenceError: Invalid left-hand side in assignment
</pre>
<pre class="brush: js;">
Uncaught TypeError: Converting circular structure to JSON
</pre>
<pre class="brush: js;">
Unexpected token ;
</pre>
<pre class="brush: js;">
Uncaught SyntaxError: Unexpected token ILLEGAL
</pre>
<pre class="brush: js;">
Uncaught TypeError: Cannot read property ‘foo’ of null,
Uncaught TypeError: Cannot read property ‘foo’ of undefined
</pre>
<pre class="brush: js;">
Uncaught TypeError: Cannot set property ‘foo’ of null,
Uncaught TypeError: Cannot set property ‘foo’ of undefined
</pre>
<pre class="brush: js;">
Uncaught RangeError: Maximum call stack size exceeded
</pre>
<pre class="brush: js;">
Uncaught URIError: URI malformed
</pre>
<pre class="brush: js;">
XMLHttpRequest cannot load http://some/url/. No ‘Access-Control-Allow-Origin’ header is present on the requested resource
</pre>
<pre class="brush: js;">
InvalidStateError: An attempt was made to use an object that is not, or is no longer, usable
</pre> -->
<script type="text/javascript-lazy" src="/scripts/syntaxhighter.js"></script>