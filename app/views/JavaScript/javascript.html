<h2>Event order</h2>
<pre class="brush: css;">
	               | |
	---------------| |-----------------
	| element1     | |                |
	|   -----------| |-----------     |
	|   |element2  \ /          |     |
	|   -------------------------     |
	|        Event CAPTURING          |
	-----------------------------------
</pre>

<pre class="brush: css;">
	               / \
	---------------| |-----------------
	| element1     | |                |
	|   -----------| |-----------     |
	|   |element2  | |          |     |
	|   -------------------------     |
	|        Event BUBBLING           |
	-----------------------------------
</pre>
<p>Function declarations and variable declarations are always moved (hoisted) invisibly to the top of their containing scope by the JavaScript interpreter.</p>

<p>But in the case with function declarations, where the entire function body will be hoisted as well.</p>

<h2>JavaScript Module Pattern</h2>

<h4>Anonymous Closures</h4>
<pre class="brush: js;">
  (function () {
    // ... all vars and functions are in this scope only
    // still maintains access to all globals
  }());
</pre>

<h4>Module Export</h4>
<pre class="brush: js;">
  var MODULE = (function () {
    var my = {},
      privateVariable = 1;
    function privateMethod() {
      // ...
    }
    my.moduleProperty = 1;
    my.moduleMethod = function () {
      // ...
    };
    return my;
  }());
</pre>

<h2>basic module pattern</h2>
<pre class="brush: js;">
	var Module = (function () {

	  return {
	    publicMethod: function () {
	      // code
	    }
	  };

	})();
</pre>
<h2>Locally scoped Object Literal</h2>
<pre class="brush: js;">
	var Module = (function () {

	  // locally scoped Object
	  var myObject = {};

	  // declared with `var`, must be "private"
	  var privateMethod = function () {};

	  myObject.someMethod = function () {
	    // take it away Mr. Public Method
	  };

	  return myObject;

	})();
</pre>
OR
<pre class="brush: js;">
	var Module = (function () {

	  var privateMethod = function () {};

	  var myObject = {
	    someMethod:  function () {

	    },
	    anotherMethod:  function () {

	    }
	  };

	  return myObject;

	})();
</pre>
<h2>Accessing "Private" Methods</h2>
<pre class="brush: js;">
	var Module = (function () {

	  var privateMethod = function (message) {
	    console.log(message);
	  };

	  var publicMethod = function (text) {
	    privateMethod(text);
	  };

	  return {
	    publicMethod: publicMethod
	  };

	})();

	// Example of passing data into a private method
	// the private method will then `console.log()` 'Hello!'
	Module.publicMethod('Hello!');
</pre>
<h2>Augmentation</h2>
<pre class="brush: js;">
	var MODULE = (function (my) {
		my.anotherMethod = function () {
			// added method...
		};

		return my;
	}(MODULE || {}));
</pre>
<h2>pass Module into ModuleTwo</h2>
<pre class="brush: js;">
	var ModuleTwo = (function (Module) {

	    Module.extension = function () {
	        // another method!
	    };

	    return Module;

	})(Module || {});
</pre>
<h2>Global Import</h2>
<pre class="brush: js;">
	(function ($, YAHOO) {
		// now have access to globals jQuery (as $) and YAHOO in this code
	}(jQuery, YAHOO));
</pre>
<h2>Private Naming Conventions, using "_"</h2>
<pre class="brush: js;">
	var Module = (function () {

	  var _privateMethod = function () {
	    // private stuff
	  };

	  var publicMethod = function () {
	    _privateMethod();
	  };

	  return {
	    publicMethod: publicMethod
	  };

	})();
</pre>

<h2>tell whether page is embeded in another page or iframe</h2>
<pre class="brush: js;">
	function myFunction() {
	    if (window.top != window.self) {
	        document.getElementById("demo").innerHTML = "This window is NOT the topmost window!";
	    } else { 
	        document.getElementById("demo").innerHTML = "This window is the topmost window!";
	    } 
	}
</pre>

<h2>unique array</h2>
<pre class="brush: js;">
	function onlyUnique(value, index, self) { 
	    return self.indexOf(value) === index;
	}

	// usage example:
	var a = ['a', 1, 'a', 2, '1'];
	var unique = a.filter( onlyUnique ); // returns ['a', 1, 2, '1']


	function uniq(a) {
	    var prims = {"boolean":{}, "number":{}, "string":{}}, objs = [];

	    return a.filter(function(item) {
	        var type = typeof item;
	        if(type in prims)
	            return prims[type].hasOwnProperty(item) ? false : (prims[type][item] = true);
	        else
	            return objs.indexOf(item) >= 0 ? false : objs.push(item);
	    });
	}

	function uniqBy(a, key) {
	    var seen = {};
	    return a.filter(function(item) {
	        var k = key(item);
	        return seen.hasOwnProperty(k) ? false : (seen[k] = true);
	    })
	}
	a = [[1,2,3], [4,5,6], [1,2,3]]
	b = uniqBy(a, JSON.stringify)
	console.log(b) // [[1,2,3], [4,5,6]]
</pre>
	
<h2>get dupes</h2>
<pre class="brush: js;">
	var arr = [1, 2, 3, 1, 1, 3, 3, 4, 5, 6, 5, 5, 5, 5, 7, 8, 9, 10, 9, 9, 9];
	Array.prototype.delete = function() {
	    var arr = this;
	    var obj = {};
	    var delArr = [];
	    for (var i = 0, l = arr.length; i < l;) {
	        var key = arr[i];
	        if (typeof obj[key] == 'undefined') {
	            obj[key] = "1";
	            i++;
	            continue;
	        }
	        delArr.push(arr.splice(i, 1)[0]);
	        var l = arr.length;
	    }
	    return delArr;
	}
	var delArr = arr.delete(); //[1, 1, 3, 3, 5, 5, 5, 5, 9, 9, 9]
</pre>
<h2>.call and .apply</h2>
<p>A useful mnemonic is "A for array and C for comma."</p>
<h2>this</h2>
<p>In JavaScript this always refers to the “owner” of the function we're executing, or rather, to the object that a function is a method of.</p>
<h2>NaN is number :) Also it is the only value which does not equal itself.</h2>
<h2>ele.className and ele.getAttribute(“class”)</h2>
<p>ele.className returns a string, while ele.getAttribute(“class”) returns an object.</p>

<p>sessionStorage (as the name persists) is only available for the duration of the browser session (and is deleted when the tab is closed) - it does however survive page reloads </p>
<h2>arguments.callee</h2>
<p>It specifies the currently executing function, so arguments.callee is the current function.</p>
<h2>function.caller</h2>
<p>The function.caller property returns the function that invoked the specified function.</p>
<p>
	The new operator takes a function F and arguments: new F(arguments...). It does three easy steps:
	Create the instance of the class. It is an empty object with its __proto__ property set to F.prototype.
	Initialize the instance. The function F is called with the arguments passed and this set to be the instance.
	Return the instance
</p>
<p>
	Note that if the value of an instanceof test can change based on changes to the prototype property of constructors, it cannot be changed by changing an object prototype, because changing an object prototype is not possible in standard ECMAScript. It is however possible using the non-standard __proto__ pseudo-property.
</p>
<p>
	通过var创建的全局变量（在任何函数体之外创建的变量）不能被删除。
	没有用var创建的隐式全局变量（不考虑函数内的情况）可以被删除。
</p>
<p>
	bind returns a function which will act like the original function but with this predefined. It is usually used when you want to pass a function to an event handler or other async callback.

	call and apply will call a function immediately letting you specify both the value of this and any arguments the function will receive.
</p>

<pre class="brush: js;">
	var event = event || window.event;
	var eventUtility = {
	    addEvent : function(el, type, fn) {
	        if (typeof addEventListener !== "undefined") {
	            el.addEventListener(type, fn, false);
	        } else if (typeof attachEvent !== "undefined") {
	            el.attachEvent("on" + type, fn);
	        } else {
	            el["on" + type] = fn;
	        }
	    },
	    
	    removeEvent : function(el, type, fn) {
	        if (typeof removeEventListener !== "undefined") {
	            el.removeEventListener(type, fn, false);
	        } else if (typeof detachEvent !== "undefined") {
	            el.detachEvent("on" + type, fn);
	        } else {
	            el["on" + type] = null;
	        }
	    },
	    
	    getTarget : function(event) {
	        if (typeof event.target !== "undefined") {
	            return event.target;
	        } else {
	            return event.srcElement;
	        }
	    },
	    
	    preventDefault : function(event) {
	        if (typeof event.preventDefault !== "undefined") {
	            event.preventDefault();
	        } else {
	            event.returnValue = false;
	        }
	    },

	    stopPropagation: function(event) {   	 
	    	if (typeof event.stopPropagation !== "undefined") {
	    	    event.stopPropagation();
	    	} else {
	    	    event.cancelBubble = true;
	    	}
	    },

		getKeycode: function(event) {
			return event.which ||  event.keyCode || event.charCode;
	    },

	    getKeyCodeString: function(event) {
	    	return String.fromCharCode(this.getKeycode(event));
	    }

	};
</pre>

<p>自动分号插入: JavaScript 解析器在遇到由于缺少分号导致的解析错误时，会自动在源代码中插入分号。</p>
<pre class="brush: js;">
	(function(window, undefined) {
	    function test(options) {
	        log('testing!')

	        (options.list || []).forEach(function(i) {

	        })

	        options.value.test(
	            'long string to pass here',
	            'and another long string to pass'
	        )

	        return
	        {
	            foo: function() {}
	        }
	    }
	    window.test = test

	})(window)

	(function(window) {
	    window.someLibrary = {}

	})(window)
</pre>
<pre class="brush: js;">
	(function(window, undefined) {
	    function test(options) {

	        // Not inserted, lines got merged
	        log('testing!')(options.list || []).forEach(function(i) {

	        }); // <- 插入分号

	        options.value.test(
	            'long string to pass here',
	            'and another long string to pass'
	        ); // <- 插入分号

	        return; // <- 插入分号, 改变了 return 表达式的行为
	        { // 作为一个代码段处理

	            // a label and a single expression statement
	            foo: function() {} 
	        }; // <- 插入分号
	    }
	    window.test = test; // <- 插入分号

	// The lines got merged again
	})(window)(function(window) {
	    window.someLibrary = {}; // <- 插入分号

	})(window); //<- 插入分号
</pre>

<p>Handling changes to the value of `undefined`</p>
<pre class="brush: js;">
	'use strict;'
</pre>
<p>OR</p>
<pre class="brush: js;">
	var undefined = 123;
	(function(something, foo, undefined) {
	    // 局部作用域里的 undefined 变量重新获得了 `undefined` 值

	})('Hello World', 42);
</pre>
<p>OR</p>
<pre class="brush: js;">
	var undefined = 123;
	(function(something, foo) {
	    var undefined;
	    ...

	})('Hello World', 42);
</pre>

<p>建议不要在调用定时器函数时，为了向回调函数传递参数而使用字符串的形式。当需要向回调函数传递参数时，可以创建一个匿名函数，在函数内执行真实的回调函数。</p>
<pre class="brush: js;">
	function foo(a, b, c) {}

	// 不要这样做
	setTimeout('foo(1,2, 3)', 1000)

	// 可以使用匿名函数完成相同功能
	setTimeout(function() {
	    foo(a, b, c);
	}, 1000)
</pre>

<p>toFixed, 四舍六入五留双</p>
<p>这里“四”是指≤4 时舍去，"六"是指≥6时进上，"五"指的是根据5后面的数字来定，当5后有数时，舍5入1；当5后无有效数字时，需要分两种情况来讲：①5前为奇数，舍5入1；②5前为偶数，舍5不进。（0是偶数）</p>
<pre class="brush: js;">
	// JavaScript将小数作为浮点数对待，所以可能会产生一些四舍五入的错误
	// "四舍"
	// 0.53664——0.5366
	// 10.2731——10.27
	// 18.5049——18.50
	// 0.58344——0.5834
	// 16.4005——16.40
	// 27.1829——27.18

	// "六入"
	// 0.53666——0.5367
	// 8.3176——8.318
	// 16.7777——16.78
	// 0.58387——0.5839
	// 10.29501——10.30
	// 21.0191——21.02

	// "五留双"
    // 0.153050——0.1530
    // 12.6450——12.64
    // 18.2750——18.28
    // 0.153750——0.1538
    // 12.7350——12.74
    // 21.845000——21.84
    
    // 0.326552——0.3266
    // 12.73507——12.74
    // 21.84502——21.85
    // 12.64501——12.65
    // 18.27509——18.28
    // 38.305000001——38.31

	0.1 + 0.2; // 0.30000000000000004
	(0.1 + 0.2).toFixed(); // "0"
	(0.1 + 0.2).toFixed(1); // "0.3"
</pre>
<!-- <h2>JavaScript Errors</h2>
<pre class="brush: js;">
Uncaught TypeError: undefined is not a function
</pre>
<pre class="brush: js;">
Uncaught ReferenceError: Invalid left-hand side in assignment
</pre>
<pre class="brush: js;">
Uncaught TypeError: Converting circular structure to JSON
</pre>
<pre class="brush: js;">
Unexpected token ;
</pre>
<pre class="brush: js;">
Uncaught SyntaxError: Unexpected token ILLEGAL
</pre>
<pre class="brush: js;">
Uncaught TypeError: Cannot read property ‘foo’ of null,
Uncaught TypeError: Cannot read property ‘foo’ of undefined
</pre>
<pre class="brush: js;">
Uncaught TypeError: Cannot set property ‘foo’ of null,
Uncaught TypeError: Cannot set property ‘foo’ of undefined
</pre>
<pre class="brush: js;">
Uncaught RangeError: Maximum call stack size exceeded
</pre>
<pre class="brush: js;">
Uncaught URIError: URI malformed
</pre>
<pre class="brush: js;">
XMLHttpRequest cannot load http://some/url/. No ‘Access-Control-Allow-Origin’ header is present on the requested resource
</pre>
<pre class="brush: js;">
InvalidStateError: An attempt was made to use an object that is not, or is no longer, usable
</pre> -->
<script type="text/javascript-lazy" src="/scripts/syntaxhighter.js"></script>